<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebGL1 — Gradiente + Estrelas + Twinkle + Pontos</title>
<style>
  /* remove margens e faz o canvas preencher a janela */
  html,body { height:100%; margin:0; background:#000; }
  canvas { display:block; width:100%; height:100%; }
</style>
</head>
<body>

<!-- Canvas único: abrindo este arquivo diretamente (file://) funcionará -->
<canvas id="glcanvas"></canvas>

<script>
/* ===========================
   Inicialização básica
   =========================== */

/* pega o canvas pelo id */
var canvas = document.getElementById('glcanvas');

/* ajusta o tamanho do canvas em pixels para coincidir com o CSS exibido */
canvas.width  = canvas.clientWidth;
canvas.height = canvas.clientHeight;

/* tenta obter contexto WebGL1 */
var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

/* log no console (útil para debug) */
console.log("canvas:", canvas);
console.log("gl:", gl);

/* se gl for null, o navegador não disponibilizou WebGL */
if (!gl) {
  alert("WebGL não disponível neste navegador.");
}

/* habilita blending para suportar transparência (estrelas suaves) */
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

/* cor de limpeza — opcional (preto) */
gl.clearColor(0,0,0,1);


/* ===========================
   HELPERS para compilar shaders e criar programas (com checagem de erros)
   =========================== */

/* compila um shader (vertex ou fragment) */
function compileShader(source, type) {
  var shader = gl.createShader(type);                // cria shader
  gl.shaderSource(shader, source);                   // fornece código GLSL
  gl.compileShader(shader);                          // compila
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    /* se erro, mostra log e lança erro para interromper (útil ao debugar) */
    console.error("Shader compile error:", gl.getShaderInfoLog(shader));
    throw new Error("Shader compile failed");
  }
  return shader;
}

/* cria programa a partir dos sources vertex+fragment */
function createProgram(vsSource, fsSource) {
  var vs = compileShader(vsSource, gl.VERTEX_SHADER);    // compila vertex
  var fs = compileShader(fsSource, gl.FRAGMENT_SHADER);  // compila fragment
  var prog = gl.createProgram();                         // cria programa
  gl.attachShader(prog, vs);                             // anexa vertex
  gl.attachShader(prog, fs);                             // anexa frag
  gl.linkProgram(prog);                                  // linka
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error("Program link error:", gl.getProgramInfoLog(prog));
    throw new Error("Program link failed");
  }
  return prog;
}


/* ===========================
   SHADERS: BACKGROUND (WebGL1 / GLSL ES 1.00)
   - faz gradiente vertical
   - gera estrelas em uma grade
   - aplica twinkle (via uTime)
   =========================== */

var bgVertexSrc = [
  "attribute vec2 aPosition;",        // recebe posição 2D do quad fullscreen
  "void main() {",
  "  gl_Position = vec4(aPosition, 0.0, 1.0);", // passa para pipeline
  "}"
].join("\n");

var bgFragmentSrc = [
  "precision mediump float;",
  "uniform vec2 uResolution;",        // resolução do canvas em pixels
  "uniform float uTime;",             // tempo em segundos
  "",
  /* função hash simples para pseudo-aleatoriedade por célula */
  "float hash(vec2 p) {",
  "  p = fract(p * 0.3183099 + vec2(0.71, 0.113));",
  "  p *= 17.0;",
  "  return fract(p.x * p.y * (p.x + p.y));",
  "}",
  "",
  "void main() {",
  "  vec2 uv = gl_FragCoord.xy;",                 // coordenada do pixel
  "",
  "  // GRADIENTE AZUL -> ROXO (vertical)",
  "  vec3 c1 = vec3(0.05, 0.10, 0.40);",
  "  vec3 c2 = vec3(0.40, 0.10, 0.55);",
  "  float t = uv.y / uResolution.y;",            // normaliza Y para 0..1
  "  vec3 bg = mix(c1, c2, t);",
  "",
  "  // ESTRELAS EM GRADE",
  "  float cellSize = 45.0;",                     // tamanho da célula em px
  "  vec2 cell = floor(uv / cellSize);",          // índice da célula atual
  "  float h = hash(cell);",                      // valor pseudo aleatório por célula",
  "",
  "  // pequena chance de ter estrela nesta célula",
  "  if (h > 0.98) {",                            // ~2% das células têm estrela",
  "    vec2 local = fract(uv / cellSize) - 0.5;",// posição local dentro da célula (centro 0,0)",
  "    float d = max(abs(local.x), abs(local.y));",
  "    float base = smoothstep(0.5, 0.0, d);     // quadrado suave",
  "",
  "    // TWINKLE: pulso suave baseado em tempo + hash da célula",
  "    float tw = 0.8 + 0.2 * sin(uTime * 5.0 + h * 40.0);",
  "",
  "    // adiciona brilho branco (com alpha implícito em bg) — aqui tratamos como cor RGB",
  "    bg += base * tw * 1.0;",
  "  }",
  "",
  "  gl_FragColor = vec4(bg, 1.0);",
  "}"
].join("\n");

/* cria o programa do background e pega locais de atributos/uniforms */
var bgProgram = createProgram(bgVertexSrc, bgFragmentSrc);
var bg_aPositionLoc = gl.getAttribLocation(bgProgram, "aPosition");
var bg_uResolutionLoc = gl.getUniformLocation(bgProgram, "uResolution");
var bg_uTimeLoc = gl.getUniformLocation(bgProgram, "uTime");


/* ===========================
   BUFFER DO QUAD FULLSCREEN (para desenhar o background)
   - usaremos TRIANGLE_STRIP com 4 vértices cobrindo [-1,1]^2
   =========================== */

var quadVerts = new Float32Array([
  -1, -1,
   1, -1,
  -1,  1,
   1,  1
]);

var quadBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);


/* ===========================
   SHADERS DOS PONTOS (WebGL1)
   - vertex: attributes para posição (vec2), tamanho (float), cor (vec3)
   - fragment: usa varying para receber cor
   =========================== */

var pointVertexSrc = [
  "attribute vec2 aPosition;",      // posição XY (já em clip-space para simplicidade)
  "attribute float aPointSize;",    // tamanho do ponto em pixels
  "attribute vec3 aColor;",         // cor RGB
  "varying vec3 vColor;",           // varia para fragment shader
  "void main() {",
  "  vColor = aColor;",
  "  gl_PointSize = aPointSize;",   // define tamanho do ponto (quadrado)
  "  gl_Position = vec4(aPosition, 0.0, 1.0);",
  "}"
].join("\n");

var pointFragmentSrc = [
  "precision mediump float;",
  "varying vec3 vColor;",           // recebe do vertex
  "void main() {",
  "  gl_FragColor = vec4(vColor, 1.0);", // pinta o ponto com a cor
  "}"
].join("\n");

/* cria programa dos pontos e localiza atributos */
var pointProgram = createProgram(pointVertexSrc, pointFragmentSrc);
var pt_aPositionLoc = gl.getAttribLocation(pointProgram, "aPosition");
var pt_aPointSizeLoc = gl.getAttribLocation(pointProgram, "aPointSize");
var pt_aColorLoc = gl.getAttribLocation(pointProgram, "aColor");


/* ===========================
   DADOS DOS PONTOS (mesmo que você forneceu)
   Formato por vértice: x, y, size, r, g, b  (6 floats => stride 24 bytes)
   IMPORTANTE: aqui assumimos que as posições já estão em clip-space (-1..1)
   =========================== */

var vertData = new Float32Array([
  -0.6618,-0.7687, 50, 0.5849, 0.7600, 0.4662,
  -0.3149, 0.7417, 10, 0.9232, 0.9332, 0.4260,
   0.9749,-0.8996, 40, 0.6969, 0.5353, 0.1471,
  -0.9202,-0.2956, 90, 0.2899, 0.9056, 0.7799,
   0.4550,-0.0642, 20, 0.2565, 0.6451, 0.8498,
   0.6192, 0.5755, 70, 0.6133, 0.8137, 0.4046,
  -0.5946, 0.7057, 20, 0.6745, 0.5229, 0.4518,
   0.6365, 0.7236, 70, 0.4690, 0.0542, 0.7396,
   0.8625,-0.0835, 20, 0.3708, 0.6588, 0.8611,
   0.7997, 0.4695, 70, 0.7490, 0.3797, 0.6879
]);

var pointBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
gl.bufferData(gl.ARRAY_BUFFER, vertData, gl.STATIC_DRAW);


/* ===========================
   RENDER LOOP
   - desenha primeiro o background (quad) e depois os pontos
   - usa requestAnimationFrame para animação do twinkle
   =========================== */

function render(timeMs) {
  /* limpa o framebuffer */
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);

  /* ---------- desenha o background ---------- */
  gl.useProgram(bgProgram);

  /* enviar uniforms do background */
  gl.uniform2f(bg_uResolutionLoc, canvas.width, canvas.height);
  gl.uniform1f(bg_uTimeLoc, timeMs * 0.001); // converte ms -> s

  /* configura atributo do quad */
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  gl.enableVertexAttribArray(bg_aPositionLoc);
  gl.vertexAttribPointer(bg_aPositionLoc, 2, gl.FLOAT, false, 0, 0);

  /* desenha dois triângulos como TRIANGLE_STRIP (4 vértices) */
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  /* ---------- desenha os pontos por cima ---------- */
  gl.useProgram(pointProgram);

  /* vincula buffer dos pontos e configura atributos com stride */
  gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);

  /* cada vértice tem 6 floats = 6 * 4 bytes = 24 bytes stride */
  var stride = 6 * 4;

  /* aPosition: 2 floats, offset 0 */
  gl.enableVertexAttribArray(pt_aPositionLoc);
  gl.vertexAttribPointer(pt_aPositionLoc, 2, gl.FLOAT, false, stride, 0);

  /* aPointSize: 1 float, offset 8 bytes */
  gl.enableVertexAttribArray(pt_aPointSizeLoc);
  gl.vertexAttribPointer(pt_aPointSizeLoc, 1, gl.FLOAT, false, stride, 2 * 4);

  /* aColor: 3 floats, offset 12 bytes */
  gl.enableVertexAttribArray(pt_aColorLoc);
  gl.vertexAttribPointer(pt_aColorLoc, 3, gl.FLOAT, false, stride, 3 * 4);

  /* desenha 10 pontos */
  gl.drawArrays(gl.POINTS, 0, 10);

  /* pede próximo frame */
  requestAnimationFrame(render);
}

/* inicia a animação */
requestAnimationFrame(render);

</script>

</body>
</html>
